/**
 * @file huffman_tree.hpp
 * @brief Definition of the HuffmanNode structure and HuffmanTree class for
 * data compression
 */
#pragma once
#include <fstream>
#include <memory>
#include <queue>
#include <string>
#include <unordered_map>

/**
 * @struct HuffmanNode
 * @brief Structure representing a node in the Huffman tree
 *
 * Each node can be a leaf (containing a symbol) or an internal node
 * (containing references to left and right subtrees).
 */
struct HuffmanNode {
  std::string symbol;   ///< Character stored in the node (only for leaves)
  int freq;    ///< Frequency of the character or sum of the children's frequencies
  std::shared_ptr<HuffmanNode> left;  ///< Pointer to the left child
  std::shared_ptr<HuffmanNode> right; ///< Pointer to the right child

  /**
   * @brief Constructor for leaf node
   *
   * Creates a leaf node containing a symbol and its frequency.
   *
   * @param s Character to be stored in the node
   * @param f Frequency of the character
   */
  HuffmanNode(std::string s, int f)
      : symbol(s), freq(f), left(nullptr), right(nullptr) {}

  /**
   * @brief Constructor for internal node
   *
   * Creates an internal node that combines two child nodes. The frequency
   * of the internal node is the sum of the children's frequencies.
   *
   * @param l Pointer to the left child node
   * @param r Pointer to the right child node
   */
  HuffmanNode(std::shared_ptr<HuffmanNode> l, std::shared_ptr<HuffmanNode> r)
      : symbol(""), freq(l->freq + r->freq), left(l), right(r) {}

  /**
   * @brief Checks if the node is a leaf
   *
   * @return true if the node has no children, false otherwise
   */
  bool isLeaf() const { return not left && not right; }
};

/**
 * @class HuffmanTree
 * @brief Implements a Huffman tree for data compression
 *
 * The Huffman tree is an optimal binary tree for encoding
 * where more frequent characters have shorter codes.
 *
 * @note The tree follows the prefix property: no code is
 *       a prefix of another code, allowing unique decoding.
 */
class HuffmanTree {
private:
  std::shared_ptr<HuffmanNode> root; ///< Root of the Huffman tree
  std::unordered_map<std::string, std::string>
      codeTable; ///< Encoding table character->code

  /**
   * @brief Builds the code table by recursively traversing the tree
   *
   * Assigns '0' for left branching and '1' for right branching.
   *
   * @param node Current node being processed
   * @param code Binary code accumulated up to the current node
   */
  void buildCodes(std::shared_ptr<HuffmanNode> node, const std::string &code);

public:
  /**
   * @brief Default constructor - creates an empty tree
   */
  HuffmanTree() : root(nullptr) {}

  /**
   * @brief Constructor that creates the tree from a frequency table
   *
   * Builds the optimal Huffman tree using a greedy algorithm based
   * on a priority queue (min-heap).
   *
   * @param freq Unordered map containing characters and their frequencies
   */
  HuffmanTree(const std::string &tablePath);

  /**
   * @brief Returns the encoding table generated by the tree
   *
   * @return std::unordered_map<std::string, std::string> Table mapping each
   *         character to its corresponding binary code
   *
   * @note Codes are strings containing only '0' and '1'
   * @note Characters not present in the tree will not be in the table
   */
  std::unordered_map<std::string, std::string> getCodeTable() const;

  /**
   * @brief Returns the root of the Huffman tree
   *
   * @return std::shared_ptr<HuffmanNode> Pointer to the root node
   */
  std::shared_ptr<HuffmanNode> getRoot() const;

   /**
   * @brief Loads a frequency table from a text file
   *
   * The file must follow the format:
   * - One entry per line in the format "string:frequency"
   * - Empty lines are ignored
   *
   * @param tablePath Path to the file containing the frequency table
   * @return std::unordered_map<std::string, int> Map containing the symbols and their
   * respective frequencies
   */
  std::unordered_map<std::string, int>
  loadFrequencyTable(const std::string &tablePath);
};